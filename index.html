<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CS:GO Inventory Value</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon" />
  <style>
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      margin: 2rem;
      max-width: 1100px;
    }

    body.no-scroll {
      overflow: hidden;
    }

    h1 {
      margin: 0;
    }

    #controls {
      margin-top: 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .btn {
      padding: 0.35rem 0.75rem;
      border: 1px solid #ccc;
      border-radius: 0.4rem;
      background: #f8f9fb;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .btn:hover {
      background: #eef2ff;
    }

    .btn.active {
      background: #3949ab;
      color: #fff;
      border-color: #3949ab;
      font-weight: 600;
    }

    .language-picker {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .language-picker select {
      padding: 0.3rem 0.5rem;
      border-radius: 0.4rem;
      border: 1px solid #cbd5f5;
      background: #f8fafc;
    }

    #summary {
      margin-top: 1.5rem;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
    }

    .summary-card {
      border: 1px solid #e3e8ef;
      border-radius: 0.75rem;
      padding: 1rem;
      background: #fdfdff;
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.04);
    }

    .summary-label {
      font-size: 0.9rem;
      color: #64748b;
      margin-bottom: 0.25rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .summary-value {
      font-size: 1.6rem;
      font-weight: 600;
      color: #0f172a;
    }

    .summary-delta {
      margin-top: 0.3rem;
      font-size: 0.95rem;
      font-weight: 500;
    }

    #charts {
      margin-top: 2rem;
      display: grid;
      gap: 2rem;
    }

    .chart-card {
      border: 1px solid #e3e8ef;
      border-radius: 0.75rem;
      padding: 1.5rem;
      padding-bottom: 2.5rem;
      background: #fff;
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.05);
      position: relative;
      display: flex;
      flex-direction: column;
    }

    .chart-card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
    }

    .chart-card-header h2 {
      margin: 0;
      font-size: 1.25rem;
    }

    .fullscreen-toggle {
      padding: 0.3rem 0.6rem;
      border-radius: 0.4rem;
      border: 1px solid #cbd5f5;
      background: #eef2ff;
      color: #1e3a8a;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .fullscreen-toggle:hover {
      background: #dbeafe;
    }

    .chart-card-body {
      margin-top: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      height: 420px;
      width: calc(100vw - 5vw);
    }

    .chart-card-body canvas {
      flex: 1;
      width: 100%;
    }

    .chart-card.fullscreen {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      padding: 2rem;
      border-radius: 0;
      box-shadow: none;
      z-index: 1000;
    }

    .chart-card.fullscreen .chart-card-body {
      height: calc(100vh - 140px);
      width: calc(100vw - 50vw);
    }

    .chart-card.fullscreen .fullscreen-toggle {
      background: #1e3a8a;
      color: #fff;
      border-color: #1e3a8a;
    }

    #daily-change {
      font-size: 1rem;
    }

    #meta {
      color: #64748b;
      font-size: 0.9rem;
    }

    @media (max-width: 640px) {
      .language-picker {
        margin-left: 0;
        width: 100%;
        justify-content: flex-start;
      }

      .chart-card.fullscreen {
        padding: 1rem;
      }
    }
  </style>
</head>

<body>
  <h1 data-i18n="title">CS Inventory Value</h1>
  <p style="margin-top:.25rem;opacity:.7;" data-i18n="subtitle">Auto-updated daily :3</p>

  <div id="controls">
    <span data-i18n="viewLabel">View:</span>
    <button class="btn active" data-span="7" data-i18n="span7">7 days</button>
    <button class="btn" data-span="30" data-i18n="span30">30 days</button>
    <button class="btn" data-span="90" data-i18n="span90">90 days</button>
    <button class="btn" data-span="all" data-i18n="spanAll">All</button>
    <div class="language-picker">
      <label for="language-select" data-i18n="languageLabel">Language:</label>
      <select id="language-select">
        <option value="en" data-i18n="languageEnglish">English</option>
        <option value="de" data-i18n="languageGerman">Deutsch</option>
      </select>
    </div>
  </div>

  <section id="summary">
    <article class="summary-card">
      <div class="summary-label" data-i18n="summaryLatest">Latest Value</div>
      <div class="summary-value" id="summary-latest">—</div>
      <div class="summary-delta" id="summary-daily-delta">—</div>
    </article>
    <article class="summary-card">
      <div class="summary-label" data-i18n="summary30d">30 Day Trend</div>
      <div class="summary-value" id="summary-30d">—</div>
      <div class="summary-delta" id="summary-30d-delta">—</div>
    </article>
    <article class="summary-card">
      <div class="summary-label" data-i18n="summaryRange">All-Time Range</div>
      <div class="summary-value" id="summary-range">—</div>
      <div class="summary-delta" id="summary-at-delta">—</div>
    </article>
    <article class="summary-card">
      <div class="summary-label" data-i18n="summaryVolatility">Volatility (30d)</div>
      <div class="summary-value" id="summary-volatility">—</div>
      <div class="summary-delta" id="summary-volatility-desc">—</div>
    </article>
  </section>

  <section id="charts">
    <div class="chart-card" data-chart="total">
      <div class="chart-card-header">
        <h2 data-i18n="totalValueHeading">Total Inventory Value</h2>
        <button class="fullscreen-toggle" type="button" data-i18n="expand">Expand</button>
      </div>
      <div class="chart-card-body">
        <canvas id="chart"></canvas>
        <div id="daily-change"></div>
      </div>
    </div>

    <!-- 
    <div class="chart-card" data-chart="accounts">
      <div class="chart-card-header">
        <h2 data-i18n="valueByAccountHeading">Value By Account</h2>
        <button class="fullscreen-toggle" type="button" data-i18n="expand">Expand</button>
      </div>
      <div class="chart-card-body">
        <canvas id="account-chart"></canvas>
        <div id="meta"></div>
      </div>
    </div>
    -->
  </section>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="js/chartjs-plugin-zoom.min.js"></script>
  <script>
    Chart.register(ChartZoom);
  </script>
  <script>
    const translations = {
      en: {
        documentTitle: 'CS Inventory Value',
        title: 'CS Inventory Value',
        subtitle: 'Auto-updated daily :3',
        viewLabel: 'View:',
        span7: '7 days',
        span30: '30 days',
        span90: '90 days',
        spanAll: 'All',
        languageLabel: 'Language:',
        languageEnglish: 'English',
        languageGerman: 'German',
        summaryLatest: 'Latest Value',
        summary30d: '30 Day Trend',
        summaryRange: 'All-Time Range',
        summaryVolatility: 'Volatility (30d)',
        totalValueHeading: 'Total Inventory Value',
        valueByAccountHeading: 'Value By Account',
        expand: 'Expand',
        collapse: 'Exit Fullscreen',
        changeSinceYesterday: 'Change since yesterday: {value}',
        changeSinceYesterdayNA: 'Change since yesterday: —',
        trackingAccounts: 'Tracking {count} account(s).',
        noAccountHistory: 'No account-level history available yet.',
        rangeSpread: 'Span: {value}',
        volatilityPercent: '{value}% of current',
        notAvailable: '—'
      },
      de: {
        documentTitle: 'CS-Inventarwert',
        title: 'CS-Inventarwert',
        subtitle: 'Täglich automatisch aktualisiert :3',
        viewLabel: 'Ansicht:',
        span7: '7 Tage',
        span30: '30 Tage',
        span90: '90 Tage',
        spanAll: 'Gesamt',
        languageLabel: 'Sprache:',
        languageEnglish: 'Englisch',
        languageGerman: 'Deutsch',
        summaryLatest: 'Aktueller Wert',
        summary30d: 'Trend (30 Tage)',
        summaryRange: 'Spanne (Gesamtzeitraum)',
        summaryVolatility: 'Volatilität (30 Tage)',
        totalValueHeading: 'Gesamtwert des Inventars',
        valueByAccountHeading: 'Wert nach Konto',
        expand: 'Vollbild',
        collapse: 'Vollbild schließen',
        changeSinceYesterday: 'Veränderung seit gestern: {value}',
        changeSinceYesterdayNA: 'Veränderung seit gestern: —',
        trackingAccounts: 'Verfolge {count} Konto(s).',
        noAccountHistory: 'Noch keine Kontohistorie vorhanden.',
        rangeSpread: 'Spanne: {value}',
        volatilityPercent: '{value}% des aktuellen Werts',
        notAvailable: '—'
      }
    };

    const currencySymbols = {
      AUD: 'A$',
      CAD: 'C$',
      CHF: 'Fr.',
      CNY: '¥',
      DKK: 'kr.',
      EUR: '€',
      GBP: '£',
      HKD: 'HK$',
      INR: '₹',
      JPY: '¥',
      MXN: '$',
      NOK: 'kr',
      NZD: 'NZ$',
      PLN: 'zł',
      SEK: 'kr',
      SGD: 'S$',
      THB: '฿',
      TRY: '₺',
      USD: '$',
      ZAR: 'R'
    };

    const translationUpdaters = [];
    const languageStorageKey = 'inventory_language';
    let currentLanguage = (localStorage.getItem(languageStorageKey) || 'en').toLowerCase();
    const languageSelect = document.getElementById('language-select');

    function translate(key, params = {}) {
      const dict = translations[currentLanguage] || translations.en;
      const fallback = translations.en[key] !== undefined ? translations.en[key] : key;
      const template = dict[key] !== undefined ? dict[key] : fallback;
      return template.replace(/\{(\w+)\}/g, (match, name) => {
        return params[name] !== undefined ? params[name] : match;
      });
    }

    function registerTranslationUpdater(fn) {
      translationUpdaters.push(fn);
    }

    function applyTranslations() {
      document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.dataset.i18n;
        if (key) {
          el.textContent = translate(key);
        }
      });
      if (languageSelect) {
        Array.from(languageSelect.options).forEach(option => {
          const key = option.dataset.i18n;
          if (key) {
            option.textContent = translate(key);
          }
        });
      }
      document.title = translate('documentTitle');
      document.documentElement.setAttribute('lang', currentLanguage);
      translationUpdaters.forEach(fn => fn());
    }

    function setLanguage(lang, { skipSave } = {}) {
      if (!translations[lang]) {
        lang = 'en';
      }
      currentLanguage = lang;
      if (!skipSave) {
        localStorage.setItem(languageStorageKey, currentLanguage);
      }
      if (languageSelect) {
        languageSelect.value = currentLanguage;
      }
      applyTranslations();
    }

    if (languageSelect) {
      languageSelect.addEventListener('change', event => {
        setLanguage(event.target.value, { skipSave: false });
      });
    }

    setLanguage(currentLanguage, { skipSave: true });

    async function fetchText(url) {
      const response = await fetch(url, { cache: 'no-store' });
      if (!response.ok) {
        throw new Error(`Failed to load ${url}: ${response.status}`);
      }
      return response.text();
    }

    function parseValuesCSV(text) {
      const lines = text.trim().split('\n').filter(Boolean);
      if (lines.length <= 1) {
        return { labels: [], lowestValues: [], medianValues: [] };
      }

      const header = lines[0].split(',').map(v => v.trim().toLowerCase());
      const rows = lines.slice(1);
      const dateIdx = header.indexOf('date');
      const lowestIdx = header.indexOf('lowest');
      const medianIdx = header.indexOf('median');

      const labels = [];
      const lowestValues = [];
      const medianValues = [];

      rows.forEach(line => {
        const cols = line.split(',');
        if (!cols.length) return;
        const date = (cols[dateIdx] || '').trim();
        if (!date) return;

        const parseNumeric = idx => {
          if (idx === -1) return NaN;
          const raw = (cols[idx] || '').replace(/[^\d.-]/g, '');
          const value = parseFloat(raw);
          return Number.isFinite(value) ? value : NaN;
        };

        labels.push(date);
        lowestValues.push(parseNumeric(lowestIdx));
        medianValues.push(parseNumeric(medianIdx));
      });

      return { labels, lowestValues, medianValues };
    }

    function parseAccountsCSV(text) {
      const lines = text.trim().split('\n').filter(Boolean);
      if (lines.length <= 1) {
        return { labels: [], datasets: [], accountIds: [] };
      }

      const header = lines[0].split(',').map(v => v.trim().toLowerCase());
      const dateIdx = header.indexOf('date');
      const idIdx = header.indexOf('steam_id');
      const valueIdx = header.indexOf('value_eur');

      const latestByKey = new Map();

      lines.slice(1).forEach(line => {
        const cols = line.split(',').map(v => v.trim());
        if (cols.length < 3) return;
        const date = cols[dateIdx];
        const steamId = cols[idIdx];
        const rawValue = cols[valueIdx];
        if (!date || !steamId) return;
        const numeric = parseFloat(rawValue.replace(/[^\d.-]/g, ''));
        if (!Number.isFinite(numeric)) return;
        const key = `${date}::${steamId}`;
        latestByKey.set(key, numeric);
      });

      const perDate = new Map();
      latestByKey.forEach((value, key) => {
        const [date, steamId] = key.split('::');
        if (!perDate.has(date)) {
          perDate.set(date, new Map());
        }
        perDate.get(date).set(steamId, value);
      });

      const labels = Array.from(perDate.keys()).sort();
      const accountIds = new Set();
      perDate.forEach(map => {
        map.forEach((_, steamId) => accountIds.add(steamId));
      });

      const sortedAccountIds = Array.from(accountIds).sort();
      const datasets = sortedAccountIds.map((steamId, index) => {
        const data = labels.map(date => {
          const value = perDate.get(date)?.get(steamId);
          return value === undefined ? null : parseFloat(value.toFixed(2));
        });
        return { steamId, data, index };
      });

      return { labels, datasets, accountIds: sortedAccountIds };
    }

    function computeSMA(data, window) {
      const sma = [];
      for (let i = 0; i < data.length; i++) {
        if (i < window - 1) {
          sma.push(null);
        } else {
          const slice = data.slice(i - window + 1, i + 1);
          const sum = slice.reduce((a, b) => a + b, 0);
          sma.push(sum / window);
        }
      }
      return sma;
    }

    function formatCurrency(value, currency, symbol) {
      if (!Number.isFinite(value)) return translate('notAvailable');
      const options = {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2,
      };
      if (symbol) {
        options.style = 'currency';
        options.currency = currency;
      } else {
        options.style = 'decimal';
      }
      const formatter = new Intl.NumberFormat(undefined, options);
      const formatted = formatter.format(value);
      return symbol ? formatted : `${formatted} ${currency}`;
    }

    function formatDelta(value, currency, symbol) {
      if (!Number.isFinite(value)) return translate('notAvailable');
      const prefix = value > 0 ? '+' : '';
      return `${prefix}${formatCurrency(value, currency, symbol)}`;
    }

    function percentChange(current, previous) {
      if (!Number.isFinite(current) || !Number.isFinite(previous) || previous === 0) return null;
      return ((current - previous) / previous) * 100;
    }

    function setupFullscreen(card, chartInstance) {
      const button = card?.querySelector('.fullscreen-toggle');
      if (!button || !chartInstance) return;

      const updateButtonLabel = () => {
        const key = card.classList.contains('fullscreen') ? 'collapse' : 'expand';
        button.textContent = translate(key);
      };

      const updateBodyLock = () => {
        const isAnyFullscreen = document.querySelector('.chart-card.fullscreen');
        document.body.classList.toggle('no-scroll', Boolean(isAnyFullscreen));
      };

      button.addEventListener('click', () => {
        document.querySelectorAll('.chart-card.fullscreen').forEach(el => {
          if (el !== card) {
            el.classList.remove('fullscreen');
            const otherButton = el.querySelector('.fullscreen-toggle');
            if (otherButton) {
              otherButton.textContent = translate('expand');
            }
          }
        });

        const isActive = card.classList.toggle('fullscreen');
        updateBodyLock();
        setTimeout(() => chartInstance.resize(), isActive ? 120 : 60);
        updateButtonLabel();
      });

      registerTranslationUpdater(updateButtonLabel);
      updateButtonLabel();
    }

    (async () => {
      const [valuesText, accountsText, configResponse] = await Promise.all([
        fetchText('values.csv'),
        fetchText('accounts.csv').catch(() => ''),
        fetch('config.json', { cache: 'no-store' }).then(r => (r.ok ? r.json() : { currency: 'EUR' })).catch(() => ({ currency: 'EUR' }))
      ]);

      const config = configResponse || {};
      const accountLabels = config.account_labels || {};
      const currency = (config.currency || 'EUR').toUpperCase();
      const currencySymbol = currencySymbols[currency] || null;

      if (!localStorage.getItem(languageStorageKey)) {
        const configLanguage = (config.language || '').slice(0, 2).toLowerCase();
        if (configLanguage && translations[configLanguage]) {
          setLanguage(configLanguage, { skipSave: true });
        }
      }

      const { labels, lowestValues, medianValues } = parseValuesCSV(valuesText);
      const accountData = accountsText ? parseAccountsCSV(accountsText) : { labels: [], datasets: [], accountIds: [] };

      const unit = currency;
      const ctx = document.getElementById('chart').getContext('2d');
      const primaryValues = medianValues.some(v => Number.isFinite(v) && v > 0) ? medianValues : lowestValues;

      const latest = primaryValues[primaryValues.length - 1];
      const previous = primaryValues[primaryValues.length - 2];

      const delta = Number.isFinite(latest) && Number.isFinite(previous) ? latest - previous : NaN;
      const deltaPct = percentChange(latest, previous);

      const idx30 = primaryValues.length > 30 ? primaryValues.length - 31 : 0;
      const base30 = primaryValues[idx30];
      const delta30 = Number.isFinite(latest) && Number.isFinite(base30) ? latest - base30 : NaN;
      const delta30Pct = percentChange(latest, base30);

      const filteredValues = primaryValues.filter(Number.isFinite);
      const high = filteredValues.length ? Math.max(...filteredValues) : NaN;
      const low = filteredValues.length ? Math.min(...filteredValues) : NaN;
      const rangeText = filteredValues.length ? `${formatCurrency(low, unit, currencySymbol)} → ${formatCurrency(high, unit, currencySymbol)}` : translate('notAvailable');
      const rangeDelta = filteredValues.length ? translate('rangeSpread', { value: formatCurrency(high - low, unit, currencySymbol) }) : translate('notAvailable');

      const windowValues = filteredValues.slice(-30);
      let volatility = NaN;
      if (windowValues.length > 1) {
        const mean = windowValues.reduce((acc, val) => acc + val, 0) / windowValues.length;
        const variance = windowValues.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / (windowValues.length - 1);
        volatility = Math.sqrt(variance);
      }
      const volatilityDesc = Number.isFinite(volatility) && Number.isFinite(latest)
        ? translate('volatilityPercent', { value: ((volatility / latest) * 100).toFixed(2) })
        : translate('notAvailable');

      document.getElementById('summary-latest').textContent = formatCurrency(latest, unit, currencySymbol);
      document.getElementById('summary-daily-delta').textContent = [
        formatDelta(delta, unit, currencySymbol),
        deltaPct !== null ? `(${deltaPct.toFixed(2)}%)` : ''
      ].filter(Boolean).join(' ') || translate('notAvailable');
      document.getElementById('summary-30d').textContent = Number.isFinite(latest) ? formatCurrency(latest, unit, currencySymbol) : translate('notAvailable');
      document.getElementById('summary-30d-delta').textContent = [
        formatDelta(delta30, unit, currencySymbol),
        delta30Pct !== null ? `(${delta30Pct.toFixed(2)}%)` : ''
      ].filter(Boolean).join(' ') || translate('notAvailable');
      document.getElementById('summary-range').textContent = rangeText;
      document.getElementById('summary-at-delta').textContent = rangeDelta;
      document.getElementById('summary-volatility').textContent = Number.isFinite(volatility) ? formatCurrency(volatility, unit, currencySymbol) : translate('notAvailable');
      document.getElementById('summary-volatility-desc').textContent = volatilityDesc;

      const chartConfig = {
        type: 'line',
        data: {
          labels,
          datasets: [
            { label: `Lowest Price (${unit})`, data: lowestValues, borderColor: 'red', tension: 0.2, fill: false },
            { label: `Median Price (${unit})`, data: medianValues, borderColor: 'blue', tension: 0.2, fill: false },
            { label: '7-day Avg', data: computeSMA(medianValues, 7), borderColor: 'orange', borderDash: [5, 5], fill: false }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { ticks: { autoSkip: true, maxTicksLimit: 12 } },
            y: { beginAtZero: true }
          },
          plugins: {
            legend: { position: 'top' },
            zoom: {
              zoom: {
                wheel: { enabled: true },
                drag: { enabled: true },
                mode: 'x'
              },
              pan: {
                enabled: true,
                mode: 'x'
              }
            }
          },
          onDblClick: chart => chart.resetZoom()
        }
      };

      const chart = new Chart(ctx, chartConfig);
      const dailyChangeEl = document.getElementById('daily-change');
      let lastDiffValue = NaN;

      const setDailyChange = diff => {
        if (Number.isFinite(diff)) {
          const diffText = formatDelta(diff, unit, currencySymbol);
          dailyChangeEl.textContent = translate('changeSinceYesterday', { value: diffText });
          dailyChangeEl.style.color = diff >= 0 ? 'green' : 'red';
        } else {
          dailyChangeEl.textContent = translate('changeSinceYesterdayNA');
          dailyChangeEl.style.color = '#334155';
        }
      };

      registerTranslationUpdater(() => setDailyChange(lastDiffValue));

      ctx.canvas.addEventListener('dblclick', () => {
        chart.resetZoom();
      });

      function updateChart(span) {
        const count = span === 'all' ? labels.length : Math.min(lowestValues.length, Number(span));

        const labelsSlice = labels.slice(-count);
        const valuesSlice = lowestValues.slice(-count);
        const medianSlice = medianValues.slice(-count);
        const smaSlice = computeSMA(medianValues, 7).slice(-count);

        chart.data.labels = labelsSlice;
        chart.data.datasets[0].data = valuesSlice;
        chart.data.datasets[1].data = medianSlice;
        chart.data.datasets[2].data = smaSlice;
        chart.update();

        const len = lowestValues.length;
        if (len >= 2) {
          const diff = lowestValues[len - 1] - lowestValues[len - 2];
          lastDiffValue = diff;
          setDailyChange(diff);
        } else {
          lastDiffValue = NaN;
          setDailyChange(NaN);
        }
      }

      document.querySelectorAll('.btn').forEach(btn => {
        btn.addEventListener('click', () => {
          chart.resetZoom();
          const active = document.querySelector('.btn.active');
          if (active) {
            active.classList.remove('active');
          }
          btn.classList.add('active');
          updateChart(btn.dataset.span);
        });
      });

      updateChart('all');

      const totalCard = document.querySelector('.chart-card[data-chart="total"]');
      if (totalCard) {
        setupFullscreen(totalCard, chart);
      }

      const accountCanvas = document.getElementById('account-chart');
      const accountCard = document.querySelector('.chart-card[data-chart="accounts"]');
      const metaEl = document.getElementById('meta');

      if (accountData.labels.length && accountData.datasets.length && accountCanvas && accountCard) {
        const accountCtx = accountCanvas.getContext('2d');
        const palette = ['#2563eb', '#9333ea', '#26a269', '#d97706', '#ef4444', '#0ea5e9', '#8b5cf6'];
        const datasets = accountData.datasets.map(ds => ({
          label: accountLabels[ds.steamId] || ds.steamId,
          data: ds.data,
          borderColor: palette[ds.index % palette.length],
          backgroundColor: `${palette[ds.index % palette.length]}33`,
          tension: 0.25,
          fill: true,
          spanGaps: true,
          stack: 'total'
        }));

        const accountChart = new Chart(accountCtx, {
          type: 'line',
          data: {
            labels: accountData.labels,
            datasets
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { ticks: { autoSkip: true, maxTicksLimit: 12 } },
              y: { stacked: true, beginAtZero: true }
            },
            plugins: {
              legend: { position: 'bottom' },
              tooltip: {
                callbacks: {
                  label: tooltipCtx => {
                    const value = tooltipCtx.parsed.y;
                    return `${tooltipCtx.dataset.label}: ${formatCurrency(value, unit, currencySymbol)}`;
                  }
                }
              }
            },
            interaction: { intersect: false, mode: 'index' }
          }
        });

        const updateMeta = () => {
          metaEl.textContent = translate('trackingAccounts', { count: accountData.datasets.length });
        };
        updateMeta();
        registerTranslationUpdater(updateMeta);
        setupFullscreen(accountCard, accountChart);
      } else {
        if (accountCanvas) {
          accountCanvas.style.display = 'none';
        }
        const accountButton = accountCard?.querySelector('.fullscreen-toggle');
        if (accountButton) {
          accountButton.style.display = 'none';
        }
        const updatePlaceholder = () => {
          metaEl.textContent = translate('noAccountHistory');
        };
        updatePlaceholder();
        registerTranslationUpdater(updatePlaceholder);
      }
    })();
  </script>
</body>

</html>